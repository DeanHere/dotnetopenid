#summary How to implement OpenID in a multiple server situation.
#labels WebFarm

= Introduction =

Presently, there is no "out-of-the-box" support for using !DotNetOpenId on a web farm or garden, but by implementing a handful of interfaces, you can serialize data so that it can be shared between servers.

As of v2.4.1, we have web.config support for dropping in an implementation DLL with no extra code required in your web app. Just specify where the implementation is using the new configuration settings (documented in the Configuration.html file that comes with the binary distribution) and specify the Assembly and class name of the implementation.

= Background =

DotNetOpenId, in order to properly handle both the Relying Party (Consumer) and Provider functions, needs to store some data between requests. When it's running on a single machine, that's pretty easy because it can just store the data in memory - it uses the [http://msdn.microsoft.com/en-us/library/system.web.httpapplicationstate.aspx HttpContext.Current.Application] state storage. Because it's in memory on only one machine, it can use regular `lock` statements to deal with synchronization issues.

Taking this into the context of a web farm, where each server has its own `HttpContext.Current.Application` state storage, if the end user accesses server A but the external OpenID server (either a Provider or a Relying Party/Consumer) accesses server B on your web farm, server B will have no previous data. It's a little like Session data, but the catch is you have different "clients" (your end user and the other OpenID server) which don't have the same cookie, so there's no way to use the built in Session object.

If you have a web farm, you likely have had to deal with how to make Sessions work with your regular web users. For example, you might use something like the ASP.NET State Server, SQL Server, or perhaps [http://www.scaleoutsoftware.com/products/stateServer/ Scaleout StateServer], to merge all your data into a single (logical) storage area. You'll need some kind of storage mechanism like that to centrally store DotNetOpenId's data too. Obviously you want something fast, but choosing a storage technology is outside the scope of this article. You'll want to be able to deal with synchronization issues (locking, etc.) with whatever storage you're using.

= Implementation walkthrough =

(This is presently a work in progress.)

== 1. Familiarize yourself with the source code. ==

If you haven't downloaded the [http://github.com/AArnott/dotnetopenid/tree/master source code for DotNetOpenId], now's a good time to do so. There are a couple of key classes to look at:
 * `Association.cs` - this is used for storing secrets and is one of the low-level types that need to be stored.
 * `Nonce.cs` - this is used for creating expiring one-time-use codes that need to be stored.
 * `IAssociationStore.cs` - this is the base interface for storing associations. You'll need to implement this interface.
 * `AssociationMemoryStore.cs` - this is an in-memory implementation of IAssociationStore. It may be helpful to reference this, though you won't be able to use a Dictionary object because that's only in memory on one machine.
 * `INonceStore.cs` - this analogous to `IAssociationStore`, but for Nonce objects.
 * `RelyingParty/IRelyingPartyApplicationStore.cs` - this is an interface for Relying Party (Consumer) applications. If you're consuming external OpenID accounts, you'll need to implement this interface. It's just a combination of `IAssociationStore` and `INonceStore`.
 * `RelyingParty/ApplicationMemoryStore.cs` - this is the in-memory implementation of `IRelyingPartyApplicationStore` for reference. It provides an example implementation of `INonceStore` and inherits from `AssociationMemoryStore` to pick up that functionality. Again, no in-memory dictionaries allowed in your implementation.

Also, take a look at the [http://github.com/AArnott/dotnetopenid/tree/v2.4/samples/ProviderCustomStore ProviderCustomStore] and the [http://github.com/AArnott/dotnetopenid/tree/v2.4/samples/RelyingPartyCustomStore RelyingPartyCustomStore] projects in the [http://github.com/AArnott/dotnetopenid/tree/v2.4/samples samples] folder. The sample projects show how to store the appropriate objects into a `DataSet`, which is in memory still, but it's helpful as another example. (The `CustomStore` samples will be removed in a future version because the new approach will be to use web.config to specify an external DLL that has an implementation for your farm.)

== 2. Implement some interfaces. ==

If you're writing a Provider (allowing external sites to authenticate users on your site), you just need to implement `IAssociationStore`. (And the `TKey` type parameter will always be `DotNetOpenId.AssociationRelyingPartyType`, if that makes it simpler at all.)

If you're writing a Relying Party / consumer, you'll need to implement `IRelyingPartyApplicationStore`, which in turn means you need to implement `INonceStore` and `IAssociationStore`.

You don't have to add code to the DotNetOpenId DLL itself. The interfaces are public, so you can put the code in another DLL or in your web project itself. This makes it easier to keep your DotNetOpenId DLL up-to-date since there's less to integrate.

See the sample projects' ([http://github.com/AArnott/dotnetopenid/tree/v2.4/samples/RelyingPartyCustomStore RelyingPartyCustomStore] and [http://github.com/AArnott/dotnetopenid/tree/v2.4/samples/ProviderCustomStore ProviderCustomStore]) `CustomStore.cs` files for examples. 

== 3. Use your interfaces. ==

=== For DotNetOpenId v2.3.x and lower ===

Rather than using the built-in ASP.NET controls, which use the default implementation of `IAssociationStore` (that is, `AssociationMemoryStore`), you'll need to write a little bit of custom code at this level.

For some example code, check the samples provided:
 * Relying Party: [http://github.com/AArnott/dotnetopenid/tree/v2.3/samples/RelyingPartyCustomStore/login.aspx.cs login.aspx.cs] in [http://github.com/AArnott/dotnetopenid/tree/v2.3/samples/RelyingPartyCustomStore RelyingPartyCustomStore]
 * Provider: [http://github.com/AArnott/dotnetopenid/tree/v2.3/samples/ProviderCustomStore/Server.aspx.cs Server.aspx.cs] in [http://github.com/AArnott/dotnetopenid/tree/v2.3/samples/ProviderCustomStore ProviderCustomStore]

=== Beginning with DotNetOpenId v2.4 ===

As of v2.4, you can use your custom storage implementations on the ASP.NET controls via the `CustomApplicationStore` property.  When the `CustomApplicationStore` is null, the default implementation is used. You can set the property in your `Page_Load` event, which occurs early enough in the [http://msdn.microsoft.com/en-us/library/ms178472.aspx ASP.NET Page Lifecycle] for the control to use the custom store correctly. Be sure to set it on every `Page_Load` as this property is not saved into the `ViewState` and will be forgotten after each request, resulting in the infamous `InvalidSignature` exception.

=== Beginning with DotNetOpenId v2.4.1 ===

Instead of using the `Page_Load` event to hook up your custom store, you can now specify the custom implementations in your web.config file, like this:
{{{
  <dotNetOpenId>
    <relyingParty>
      <store type="Fully.Namespace.Qualified.CustomRelyingPartyStore, Assembly.Name" />
    </relyingParty>
    <provider>
      <store type="Fully.Namespace.Qualified.CustomProviderStore, Assembly.Name" />
    </provider>
  </dotNetOpenId>
}}}